<?php
require_once 'global.php';
require_once 'PHPUnit/Framework.php';

/**
 * Test class for Student.
 * Generated by PHPUnit on 2009-02-12 at 12:00:17.
 */
class StudentTest extends PHPUnit_Framework_TestCase
{
    /**
     * @var    Student
     * @access protected
     */
    protected $object;

	public function testSetEmailAddress() {
		$customer_1 = new Student();
		$email = sha1(time() . rand(10,99)) . '@localhost.com';
		$this->assertEquals($email, $customer_1->setEmail($email));
		$customer_1->write();
		$this->assertTrue($customer_1->exists());
		$this->assertEquals($email, $customer_1->setEmail($email));

		$customer_2 = new Student();
		$this->assertNotEquals($email, $customer_2->setEmail($email));
		$this->assertEquals("", trim($customer_2->getEmail()));
	}

	public function customerProvider() {
		$sql = "SELECT student_id
			FROM students";
		$query = db_query_random($sql);
		$array = array();
		foreach($query as $rec) {
			$array[] = array($rec['customer_id']);
		}
		return $array;
	}

	/**
	 * Sets up the fixture, for example, opens a network connection.
	 * This method is called before a test is executed.
	 *
	 * @access protected
	 */
	protected function setUp() {
		$this->object = new Student;

		$C = new Student();
		$C->email = md5(uniqid(rand(), true)) . '@localhost.foo';
		$C->name = 'foobar foo';
		$C->write();

		$this->fixture['customer'] = $C;
	}

	/**
	 * Tears down the fixture, for example, closes a network connection.
	 * This method is called after a test is executed.
	 *
	 * @access protected
	 */
	protected function tearDown() {
		$this->fixture['customer']->delete();
	}

	/**
	 * @dataProvider customerProvider
	 */
	public function testLoginFail($customer_id) {
		$C = new Student($customer_id);

		$login_customer = new Student();
		$email = $C->getEmail();
		$pass = sha1($C->getPassword() . time() . rand(0, 100));
		$this->assertFalse($login_customer->login($email, $pass));
	}

	public function testLoginSuccess() {
		$C = new Student();
		$email = sha1(microtime() . rand(0,99)) . '@localhost.foo';
		$pass = sha1(microtime() . rand(0,99));
		$C->setEmail($email);
		$this->assertTrue($C->setPassword($pass));
		$C->newToken();
		$C->write();
		$this->assertTrue($C->exists());

		$new_customer = new Student();
		$this->assertTrue($new_customer->login($email, $pass), print_r($new_customer,true) . print_r($C, true));

		$C->delete();
		$this->assertFalse($C->exists());
	}

	public function testLogout() {
		$C = new Student();
		$email = sha1(microtime() . rand(0,99)) . '@localhost.foo';
		$pass = sha1(microtime() . rand(0,99));
		$C->setEmail($email);
		$this->assertTrue($C->setPassword($pass));
		$C->newToken();
		$C->write();
		$this->assertTrue($C->exists());

		$new_customer = new Student();
		$this->assertTrue($new_customer->login($email, $pass)); //, print_r($new_customer,true));

		$token = $new_customer->getToken();
		$this->assertGreaterThan(0, strlen($token));
		$this->assertNotNull($token);
		$new_customer->logout();

		$LOOKUP = User_Session::tokenFactory($token);
		$this->assertTrue(is_a($LOOKUP, 'Student'));
		$this->assertFalse($LOOKUP->exists());
	}

	/**
	 * @dataProvider customerProvider
	 */
	public function testSetPassword($customer_id) {
		$C = new Student($customer_id);
		$this->assertFalse($C->setPassword("asdf"), "Password set without pre-existing password.");
		$this->assertFalse($C->setPassword("asdf", sha1("asdf")));
		unset($C);

		$C = new Student();
		$bad_password = "";
		while(strlen($bad_password) < (MIN_PASSWORD_LENGTH - 1)) {
			$bad_password .= rand(0,9);
		}
		$this->assertFalse($C->setPassword($bad_password), "Password set with bad password. '$bad_password' " . MIN_PASSWORD_LENGTH);
		unset($C);

		$C = new Student();
		$good_password = $bad_password . rand(0,9);
		$this->assertTrue($C->setPassword($good_password), "New password not set with good password. '$good_password' " . MIN_PASSWORD_LENGTH);
		$C->setEmail(sha1(time()) . '@localhost.foo');
		$C->newToken();
		$C->write();
		$this->assertTrue($C->exists());
		$this->assertTrue($C->setPassword(sha1(time()), $good_password));
		$C->delete();
		$this->assertFalse($C->exists());
	}

	public function testResetPassword() {
    		$C = new Student();
    		$C->name = 'Zach Campbell';
    		$C->email = sha1(microtime() * rand(1,9)) . '@localhost.com';
    		$original_password = sha1(rand(1,100) . time());
    		$this->assertTrue($C->setPassword($original_password), print_r($C,true));
    		$C->newToken();
    		$C->write();
    		$this->assertEquals(passwordify($original_password, $C->salt), $C->password, print_r($C, true));

		recover_customer_password($C);

		$sql = "SELECT token
			  FROM `user_password_tokens`
			  WHERE user_id = '" . intval($C->ID) . "'
			  	AND user_type = '" . db_input(get_class($C)) . "'
			  	AND expiration > now()";
		$query = db_query($sql);
		$this->assertGreaterThan(0, $query->num_rows);

		$old_password = passwordify($original_password);
		while($query->num_rows > 0 && $t = $query->fetch_assoc()) {
			$new_password = sha1(rand(1,100) . microtime());
			$this->assertTrue($C->resetPassword($new_password, $t['token']));
			$this->assertEquals(passwordify($new_password, $C->salt), $C->password);
			$this->assertFalse($C->resetPassword(null, $t['token']));
			$old_password = passwordify($new_password);
		}

    }

	public function testResetBadPassword() {
		$C = new Student();
		$C->name = 'Zach Campbell';
		$email = sha1(microtime() * rand(1,9)) . '@localhost.foo';

		$this->assertEquals($email, $C->setEmail($email));
		$original_password = sha1(rand(1,100) . microtime());
		$this->assertTrue($C->setPassword($original_password), print_r($C,true));
		$C->write();
		$this->assertEquals(passwordify($original_password, $C->salt), $C->password, print_r($C, true));

		$this->assertFalse($C->resetPassword(sha1(microtime), 'bad tokenz0rz'));
	}

	public function testSetToken() {
		$C = new Student();
		$token = sha1(time() . rand(0,99));
		$C->setToken($token);
		$this->assertNotEquals($token, $C->getSessionToken());
	}

	/**
	 * @dataProvider customerProvider
	 */
	public function testGetAddressBookDataDump($customer_id) {
		$C = new Student($customer_id);
		$address_book_dump = $C->getAddressBook(true);
		$this->assertType('array', $address_book_dump);
	}

	public function testUserType() {
		$C = new Student();
		$this->assertEquals(User::TYPE_STUDENT, $C->getUserType());
	}
}
?>
